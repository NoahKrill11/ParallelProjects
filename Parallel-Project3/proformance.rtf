{\rtf1\ansi\ansicpg1252\cocoartf2576
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 According to the results that I have gotten on my first project the more processors we have the less efficient the program seems to get. For example, while the efficiency does go up with 8 threads and 4000 elements when it goes up to 8000 elements the efficiency goes right down. While the efficiency did go down according to my results the speed up did increase with more elements. The more elements and the more threads the faster it goes.\
\
The second project seems to have better results saying the more threads you have with little elements the less effective it is. The more threads with more elements the more effective it becomes. It seems to keep relatively the same speed while the examples with fewer threads take longer. The more threads seem to be less effective with less elements. When you add more elements to the mix it keeps its speed relatively close to what it started with but the ones with less threads start to grow more in time.\
\
The third project is about the same the more entries you throw at it with the more threads give better results. It does take a while to get to the point of being efficient. It takes a while to become efficient but as the time for the smaller amount threads goes up the time for the bigger amount goes down. This method seems to not be so effective up until it reaches the bigger numbers.\
\
I personally think that OpenMP is the most simple form of paralyzation but it also takes a long time to be effective. MPI seems like it is not very effective with regard to efficacy but with speed its a must have.. Pthreads seem to be the most effective all the way through the program it\'92s not the fastest but it keeps its effectiveness and has both speed and efficiency. I had the most fun working with pthreads. The compiler does most of the splitting of tasks for openMP(That might be why it isn\'92t as effective).}